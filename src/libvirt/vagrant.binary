#!/bin/bash -ex
# vi: ts=4 noexpandtab
#
# Generate a generic Vagrant Box.
#
# Vagrant images are essentially nothing more than QCOW2's with extra-metadata
# and some preinstalled packages.
#
# We can't use the QCOW2's for Vagrant since Vagrant uses SSH to modify the
# instance. This build step creates a cloud-config ISO so that Cloud-Init
# will configure the initial user, creates meta-data that tells Vagrant how
# to interact with the cloud-init created users, and finally create the QCOW2.
#
# For this step, we make a deriviative of binary/boot/disk.ext4 and install
# some packages in it, convert it to a QCOW2, and then assemble the vagrant
# box.

cur_d=${PWD}
my_d=$(dirname $(readlink -f ${0}))

ARCH=amd64

source_url="${SOURCE_IMG_URL:-https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-$ARCH.img}"
build_id="${BUILD_ID:-$(date +%Y%m%d)}"
build_d="${BUILD_DIR:-$cur_d}"

export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get install -y --no-install-recommends \
    ca-certificates \
    genisoimage \
    libguestfs-tools \
    linux-image-$(uname -r) \
    qemu-utils \
    wget \
    ;

. "${my_d}/config/functions"

# Lets be safe about this
box_d=$(mktemp -d)
seed_d=$(mktemp -d)
mount_d=$(mktemp -d)

if [ ! -f "${build_d}/binary/boot/disk.ext4" ]; then
    mkdir -p "${build_d}/binary/boot"
    wget -qO "${build_d}/binary/boot/disk.ext4" "${source_url}"
fi

create_derivative "disk" "vagrant" "${build_d}/binary/boot" #sets ${derivative_img}
mount_disk_image ${derivative_img} ${mount_d}

cleanup_vagrant() {
    if [ -d "$mount_d" ]; then
        umount_disk_image "$mount_d"
    fi
    rm -rf ${box_d} ${seed_d} ${mount_d} ${derivative_img}
}
trap cleanup_vagrant EXIT


##########################
### Vagrant User Setup
##########################

# Create and setup users inside the image.
# Vagrant users expect a "vagrant" user with a "vagrant" username.
# See https://www.vagrantup.com/docs/boxes/base.html
# Note: We decided NOT to allow root login with a default password.
chroot ${mount_d} adduser vagrant --disabled-password --gecos ""
echo "vagrant:vagrant" | chroot ${mount_d} chpasswd

# The vagrant user should have passwordless sudo.
cat << EOF > ${mount_d}/etc/sudoers.d/vagrant
vagrant ALL=(ALL) NOPASSWD:ALL
EOF

# Add an insecure vagrant pubkey to the vagrant user, as is expected by the
# vagrant ecosystem (https://www.vagrantup.com/docs/boxes/base.html)
chroot ${mount_d} chmod 0440 /etc/sudoers.d/vagrant
chroot ${mount_d} mkdir /home/vagrant/.ssh
wget -qO ${mount_d}/home/vagrant/.ssh/authorized_keys https://raw.githubusercontent.com/hashicorp/vagrant/main/keys/vagrant.pub.ed25519
chroot ${mount_d} chown -R vagrant:vagrant /home/vagrant/.ssh
chroot ${mount_d} chmod 700 /home/vagrant/.ssh

# Used to identify bits
suite=$(chroot ${mount_d} lsb_release -c -s)
version=$(chroot ${mount_d} lsb_release --release --short)
distro=$(chroot ${mount_d} lsb_release --id --short | tr [:upper:] [:lower:])

umount_disk_image "$mount_d"
rmdir "$mount_d"

# Get the QCOW2 in place
prefix="${distro}-${suite}-${version}-cloudimg"
qcow2_f="${box_d}/${prefix}.img"
create_qcow2 ${derivative_img} ${qcow2_f} 40960

####################################
# Create the ConfigDrive
# This is a cloud-init piece that instructs cloud-init to configure
# a default user at first boot.

cdrom_qcow2_f="${box_d}/${prefix}-configdrive.img"

# Create the user-data. This is totally insecure, but so is Vagrant. To
# mitigate this insecurity, the vagrant instance is not accessible
# except via local host.
cat > ${seed_d}/user-data <<END
#cloud-config
manage_etc_hosts: localhost
END

# Create the fake meta-data
cat > ${seed_d}/meta-data <<END
instance-id: iid-$(openssl rand -hex 8)
local-hostname: ubuntu-${suite}
END

# Pad the cdrom, otherwise the QCOW2 will be invalid
dd if=/dev/zero of=${seed_d}/bloat_file bs=1M count=10

# Create the ISO
genisoimage \
    -output ${seed_d}/seed.iso \
    -volid cidata \
    -joliet -rock \
    -input-charset utf-8 \
    ${seed_d}/user-data \
    ${seed_d}/meta-data

# Make a QCOW2 out of the seed file.
create_qcow2 ${seed_d}/seed.iso ${cdrom_qcow2_f} 10

### END Create ConfigDrive

##########################
# VAGRANT meta-data

# Create the Vagrant file. This file is used by Vagrant to define how
# Vagrant uses libvirt and how Vagrant interacts with the host.
cat > ${box_d}/Vagrantfile <<EOF
# Front load the includes
include_vagrantfile = File.expand_path("../include/_Vagrantfile", __FILE__)
load include_vagrantfile if File.exist?(include_vagrantfile)

Vagrant.configure("2") do |config|
  config.vm.provider :libvirt do |libvirt|
    # Create a NULL serial port to skip console logging by default
    libvirt.serial :type => "null"
    # If pseudo TTY is desired, uncomment this line and remove prior
    #libvirt.serial :type => "pty"
    # If console logging is desired, uncomment this line and remove prior
    # libvirt.serial :type => "file", :source => {:path => File.join(Dir.pwd, "${prefix}-console.log")}
    # Ubuntu cloud images, by default, enable console=ttyS0. This enables serial consoles to
    # connect to the images. With the change related to LP #1777827, removing a serial
    # file logger, Vagrant image boot times increased and now run greater than 5 minutes
    # Creating a console log file is not an expected default behavior for vagrant boxes.
    # As a workaround, we create a console connection to File:NULL. LP #1874453
    # This is overrideable in user files to write to a local file

    # Disable graphics
    libvirt.graphics_type = "none"
  end
end
EOF

# Tag it as a libvirt Vagrant
cat > ${box_d}/metadata.json <<EOF
{
  "architecture": "amd64",
  "disks": [
    {
      "format": "qcow2",
      "path": "${qcow2_f##*/}"
    },
    {
      "format": "qcow2",
      "path": "${cdrom_qcow2_f##*/}"
    }
  ],
  "provider": "libvirt"
}
EOF

# END
##########################

##########################
# Create the actual box

# Get information about the disks
qcow2_size=$(du -b "${qcow2_f}" | cut -f1)
qcow2_capacity=$(qemu-img info "${qcow2_f}" | awk '-F[\( ]' '$1 ~ /virtual/ && $NF ~ /bytes.*/ {print$(NF-1)}')
qcow2_sha256=$(sha256sum ${qcow2_f} | cut -d' ' -f1)

cdrom_size=$(du -b "${cdrom_qcow2_f}" | cut -f1)
cdrom_capacity=$(qemu-img info "${cdrom_qcow2_f}" | awk '-F[\( ]' '$1 ~ /virtual/ && $NF ~ /bytes.*/ {print$(NF-1)}')
cdrom_sha256=$(sha256sum ${cdrom_qcow2_f} | cut -d' ' -f1)

# Generate the manifest
manifest="${box_d}/${prefix}.mf"
cat > "${manifest}" <<EOF
SHA256(${qcow2_f##*/})= ${qcow2_sha256}
SHA256(${cdrom_qcow2_f##*/})= ${cdrom_sha256}
EOF

# Now create the box
echo "Creating QCOW2 with the following attributes:"
cat <<EOM
QCOW2 information:
    Name:           ${prefix}
    Size:           ${qcow2_size}
    QCOW2 Name:     ${qcow2_f##*/}
    QCOW2 Capacity: ${qcow2_capacity}
    QCOW2 SHA256:   ${qcow2_sha256}
    CDROM Name:     ${cdrom_qcow2_f##*/}
    CDROM Capacity: ${cdrom_capacity}
    CDROM SHA256:   ${cdrom_sha256}
EOM

box_f="${build_d}/${build_id}/${suite}-server-cloudimg-${ARCH}-vagrant-libvirt.box"

mkdir -p "${build_d}/${build_id}"
tar -C ${box_d} \
    --sort=name \
    -cf ${box_f} \
    Vagrantfile \
    metadata.json \
    ${prefix}.mf \
    ${qcow2_f##*/} \
    ${cdrom_qcow2_f##*/}
